<!doctype html>
<html lang="en-US">

	<head>
		<meta charset="utf-8">
		<title>Virgil Crypto Browser examples</title>
		<script type="text/javascript" src="/assets/virgil-crypto.browser.umd.js"></script>
		<style>
			img {
				display: block;
				max-width: 800px;
				margin: 0 auto;
			}
			input[type="file"] {
				display: block;
				margin: 40px auto;
			}
			li {
				margin-bottom: .5em;
			}
			button {
				margin-left: 1em;
			}
		</style>
	</head>

	<body>
		<ul id="output"></ul>
		<input type="file" id="image-input" name="image" accept="image/*" />
		<img id="img" />
	<script>
		const { VirgilCrypto } = window.VirgilCrypto;
		const virgilCrypto = new VirgilCrypto();
		const keypair = getOrCreateKeyPair();

		document.getElementById('image-input').addEventListener('change', encryptAndUpload);

		function encryptAndUpload() {
			const file = this.files[0];
			if (!file) {
				return;
			}

			const reader = new FileReader();
			// Using 64kB chunk size here, but can be arbitrary size up to 1MB
			const chunkSize = 64 * 1024;
			const fileSize = file.size;
			let offset = 0;
			let endOffset = Math.min(offset + chunkSize, fileSize);

			const streamCipher = virgilCrypto.createStreamCipher(keypair.publicKey);
			const encryptedChunks = [];
			encryptedChunks.push(streamCipher.start());

			reader.onload = () => {
				if (reader.result === null || offset === fileSize) {
					console.log('Finished encryption');
					encryptedChunks.push(streamCipher.final(reader.result));
					uploadEncryptedFile(new File(encryptedChunks, file.name, { type: file.type }));
				} else {
					console.log(`Encrypting ${endOffset - offset} byte chunk`);
					encryptedChunks.push(streamCipher.update(reader.result));

					offset = endOffset;
					endOffset = Math.min(offset + chunkSize, fileSize);
					reader.readAsArrayBuffer(file.slice(offset, endOffset));
				}
			};

			reader.onerror = () => {
				console.log('FileReader error:', reader.error);
			};

			reader.readAsArrayBuffer(file.slice(offset, endOffset));
		}

		function downloadAndDecrypt(fileDescriptor) {
			fetch('/uploads/' + fileDescriptor.filename)
			.then(response => {
				if (!response.ok) {
					console.error(`Server returned: ${response.status}:${response.statusText}`);
					return;
				}

				response.blob().then(blob => {
					const streamDecipher = virgilCrypto.createStreamDecipher(keypair.privateKey);
					const decryptedChunks = [];

					const reader = new FileReader();
					// Using 64kB chunk size here, but can be arbitrary size up to 1MB
					const chunkSize = 64 * 1024;
					const fileSize = blob.size;
					let offset = 0;
					let endOffset = Math.min(offset + chunkSize, fileSize);

					reader.onload = () => {
						if (reader.result === null || offset === fileSize) {
							console.log('Finished decryption');
							decryptedChunks.push(streamDecipher.final(reader.result));
							renderDecryptedFile(new File(decryptedChunks, fileDescriptor.name, { type: fileDescriptor.type }));
						} else {
							console.log(`Decrypting ${endOffset - offset} byte chunk`);
							decryptedChunks.push(streamDecipher.update(reader.result));

							offset = endOffset;
							endOffset = Math.min(offset + chunkSize, fileSize);
							reader.readAsArrayBuffer(blob.slice(offset, endOffset));
						}
					};

					reader.onerror = () => {
						console.log('FileReader error:', reader.error);
					};

					reader.readAsArrayBuffer(blob.slice(offset, endOffset));
				});
			});
		}

		function getOrCreateKeyPair() {
			if (localStorage.getItem('my_private_key')) {
				console.log('Loading keypair from local stroage');
				const privateKey = virgilCrypto.importPrivateKey(localStorage.getItem('my_private_key'));
				const publicKey = virgilCrypto.extractPublicKey(privateKey);
				return { privateKey, publicKey };
			}

			console.log('Creating new keypair');
			const keypair = virgilCrypto.generateKeys();
			localStorage.setItem(
				'my_private_key',
				virgilCrypto.exportPrivateKey(keypair.privateKey).toString('base64')
			);
			return keypair;
		}

		function uploadEncryptedFile(encryptedFile) {
			const formData = new FormData();
			formData.append('image', encryptedFile);

			fetch('/uploads', { method: 'POST', body: formData })
			.then(response => {
				if (response.ok) return response.json();

				throw new Error(`${response.status} - ${response.statusText}`);
			})
			.then(renderUploadResult)
			.catch(err => console.log(err));
		}

		function renderUploadResult(fileDescriptor) {
			const textEl = document.createTextNode(fileDescriptor.originalname);
			const downloadBtn = document.createElement('button');
			downloadBtn.textContent = 'Download & Display';
			downloadBtn.addEventListener('click', () => downloadAndDecrypt(fileDescriptor));

			const itemEl = document.createElement('li');
			itemEl.appendChild(textEl);
			itemEl.appendChild(downloadBtn);

			document.getElementById('output').appendChild(itemEl);
		}

		function renderDecryptedFile(decryptedFile) {
			document.getElementById('img').src = URL.createObjectURL(decryptedFile);
		}
	</script>
	</body>
</html>
